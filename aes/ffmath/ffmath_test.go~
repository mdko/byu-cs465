package ffmath

import "testing"

func TestXTime(t *testing.T) {
		inoutmap := map[byte]byte {
			0x57 : 0xae,
			0xae : 0x47,
			0x47 : 0x8e,
			0x8e : 0x07,
		}
		for in, out := range(inoutmap) {
				if x := XTime(in); x != out {
						t.Errorf("xtime(%x) = %x, want %x", in, x, out)
				}
		}
}

func TestFFMultiply(t *testing.T) {
		// map {answer : map{operand : operand} }
		inoutmap := map[byte]map[byte]byte {
				0xfe : map[byte]byte {
						0x57 : 0x13,
				},
		}
		for ans, operands  := range(inoutmap) {
				for op1, op2 := range(operands) {
						if out := FFMultiply(op1, op2); ans != out {
								t.Errorf("FFMultiply(%x, %x) = %x, want %x", op1, op2, out, ans)
						}
				}
		}
}

func TestFFAdd(t *testing.T) {
		// map {answer : map{operand : operand} }
		inoutmap := map[byte]map[byte]byte {
				0x05 : map[byte]byte {	
						0x04 : 0x01,
				},
				0x01 : map[byte]byte {
						0x03 : 0x02,
				},
				0x03 : map[byte]byte {
						0x04 : 0x07,
				},
		}
		for ans, operands  := range(inoutmap) {
				for op1, op2 := range(operands) {
						if out := FFAdd(op1, op2); ans != out {
								t.Errorf("FFAdd(%x, %x) = %x, want %x", op1, op2, out, ans)
						}
				}
		}

	//a := make([][]int, 4)	// slices
	////for i := range a {
	////		a[i] = make([]int, 4)
	////}
	//aAll := make([]int, 4*4)
	//for i := range a {
	//		a[i], aAll = aAll[:4], aAll[4:]
	//}
	//ax := len(a)
	//ay := len(a[0])
	//fmt.Println(ax, ay)

	//var b [4][5]int			// arrays
	//x := len(b)				// number in 1st dimension
	//y := len(b[0])			// number of elements in each element (2nd dim)
	//fmt.Println(x, y)
}
