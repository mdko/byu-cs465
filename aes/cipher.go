package main

import (
		"os"
)

func main() {
		in := os.Args[1]
		// Cipher(in, )
}

func Cipher(in_state[4][Nb]byte, w[Nb][Nr + 1]uint32) (out_state[4][Nb]byte) {
		var state[4][Nb]byte
		state = in_state

		state = AddRoundKey(state, w[0][Nb - 1])

		for round := 1; round < Nr; round++ {
				state = SubBytes(state)
				state = ShiftRows(state)
				state = MixColumns(state)
				state = AddRoundKey(state, w[round*Nb][(round+1)*Nb - 1])
		}

		state = SubBytes(state)
		state = ShiftRows(state)
		state = AddRoundKey(state, w[Nr*Nb][(Nr+1)*Nb - 1])

		out_state = state
		return
}

func AddRoundKey(in_state[4][Nb]byte, w[Nb][Nr + 1]uint32) (out_state[4][Nb]byte) {
		// Uses the round key generated by the key schedule
		return
}

func SubBytes(in_state[4][Nb]byte) (out_state[4][Nb]byte) {
		//
		return
}

func ShiftRows(in_state[4][Nb]byte) (out_state[4][Nb]byte) {
		return
}

func KeyExpansion(key[4][Nk]byte, w[Nb][Nr+1]uint32 /*,Nk int*/) {
		var temp uint32
		for i := 0; i < Nk; i++ {
		}
}

// This function implements the EqInvCipher function
func InvCipher(in_state[4][Nb]byte, dw[Nb][Nr + 1]byte) (out_state[4][Nb]byte) {
		var state[4][Nb] byte
		state = in_state
		AddRoundKey(state, dw[Nr*Nb][(Nr+1)*Nb - 1])
		for round := Nr - 1; round >= 1; round-- { // TODO review the bounds here
				state = InvSubBytes(state)
				state = InvShiftRows(state)
				state = InvMixColumns(state)
				state = AddRoundKey(state, dw[round*Nb][(round+1)*Nb - 1])
		}
		state = InvSubBytes(state)
		state = InvShiftRows(state)
		state = AddRoundKey(state, dw[0][Nb-1])

		out_state = state
		return
}
