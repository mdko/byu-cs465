package main

import (
		"os"
		"github.com/mdko/cs465/aes/keyexpansion"
)

func main() {
		//in := os.Args[1]
		in := [4][constants.Nb]byte {
			{ 0x32, 0x43, 0xf6, 0xa8, } ,
			{ 0x88, 0x5a, 0x30, 0x8d, } ,
			{ 0x31, 0x31, 0x98, 0xa2, } ,
			{ 0xe0, 0x37, 0x07, 0x34, } ,
		}
		cipherKey := [constants.Nk][4]byte {
			{ 0x2b, 0x7e, 0x15, 0x16, } ,
			{ 0x28, 0xae, 0xd2, 0xa6, } ,
			{ 0xab, 0xf7, 0x15, 0x88, } ,
			{ 0x09, 0xcf, 0x4f, 0x3c, } ,
		}
		roundKey := KeyExpansion(cipherKey)
		out := Cipher(in,roundKey)
		fmt.Println("Out: %v\n", out)
}

func Cipher(in_state[4][constants.Nb]byte, w[constants.Nb * (constants.Nr + 1)][4]uint32) (out_state[4][Nb]byte) {
		var state[4][Nb]byte = in_state

		state = AddRoundKey(state, w[0][Nb - 1])

		for round := 1; round < Nr; round++ {
				state = SubBytes(state)
				state = ShiftRows(state)
				state = MixColumns(state)
				state = AddRoundKey(state, w[round*Nb][(round+1)*Nb - 1])
		}

		state = SubBytes(state)
		state = ShiftRows(state)
		state = AddRoundKey(state, w[Nr*Nb][(Nr+1)*Nb - 1])

		out_state = state
		return
}

func AddRoundKey(in_state[4][Nb]byte, w[Nb][Nr + 1]uint32) (out_state[4][Nb]byte) {
		// Uses the round key generated by the key schedule
		return
}

func SubBytes(in_state[4][Nb]byte) (out_state[4][Nb]byte) {
		//
		return
}

func ShiftRows(in_state[4][Nb]byte) (out_state[4][Nb]byte) {
		return
}

// This function implements the EqInvCipher function
func InvCipher(in_state[4][Nb]byte, dw[Nb][Nr + 1]byte) (out_state[4][Nb]byte) {
		var state[4][Nb] byte
		state = in_state
		AddRoundKey(state, dw[Nr*Nb][(Nr+1)*Nb - 1])
		for round := Nr - 1; round >= 1; round-- { // TODO review the bounds here
				state = InvSubBytes(state)
				state = InvShiftRows(state)
				state = InvMixColumns(state)
				state = AddRoundKey(state, dw[round*Nb][(round+1)*Nb - 1])
		}
		state = InvSubBytes(state)
		state = InvShiftRows(state)
		state = AddRoundKey(state, dw[0][Nb-1])

		out_state = state
		return
}
